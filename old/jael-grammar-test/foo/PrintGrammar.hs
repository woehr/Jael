{-# LANGUAGE CPP #-}
#if __GLASGOW_HASKELL__ <= 708
{-# LANGUAGE OverlappingInstances #-}
#endif
{-# LANGUAGE FlexibleInstances #-}
{-# OPTIONS_GHC -fno-warn-incomplete-patterns #-}

-- | Pretty-printer for PrintGrammar.
--   Generated by the BNF converter.

module PrintGrammar where

import qualified AbsGrammar
import Data.Char

-- | The top-level printing method.

printTree :: Print a => a -> String
printTree = render . prt 0

type Doc = [ShowS] -> [ShowS]

doc :: ShowS -> Doc
doc = (:)

render :: Doc -> String
render d = rend 0 (map ($ "") $ d []) "" where
  rend i ss = case ss of
    "["      :ts -> showChar '[' . rend i ts
    "("      :ts -> showChar '(' . rend i ts
    "{"      :ts -> showChar '{' . new (i+1) . rend (i+1) ts
    "}" : ";":ts -> new (i-1) . space "}" . showChar ';' . new (i-1) . rend (i-1) ts
    "}"      :ts -> new (i-1) . showChar '}' . new (i-1) . rend (i-1) ts
    ";"      :ts -> showChar ';' . new i . rend i ts
    t  : ts@(p:_) | closingOrPunctuation p -> showString t . rend i ts
    t        :ts -> space t . rend i ts
    _            -> id
  new i   = showChar '\n' . replicateS (2*i) (showChar ' ') . dropWhile isSpace
  space t = showString t . (\s -> if null s then "" else ' ':s)

  closingOrPunctuation :: String -> Bool
  closingOrPunctuation [c] = c `elem` closerOrPunct
  closingOrPunctuation _   = False

  closerOrPunct :: String
  closerOrPunct = ")],;"

parenth :: Doc -> Doc
parenth ss = doc (showChar '(') . ss . doc (showChar ')')

concatS :: [ShowS] -> ShowS
concatS = foldr (.) id

concatD :: [Doc] -> Doc
concatD = foldr (.) id

replicateS :: Int -> ShowS -> ShowS
replicateS n f = concatS (replicate n f)

-- | The printer class does the job.

class Print a where
  prt :: Int -> a -> Doc
  prtList :: Int -> [a] -> Doc
  prtList i = concatD . map (prt i)

instance {-# OVERLAPPABLE #-} Print a => Print [a] where
  prt = prtList

instance Print Char where
  prt _ s = doc (showChar '\'' . mkEsc '\'' s . showChar '\'')
  prtList _ s = doc (showChar '"' . concatS (map (mkEsc '"') s) . showChar '"')

mkEsc :: Char -> Char -> ShowS
mkEsc q s = case s of
  _ | s == q -> showChar '\\' . showChar s
  '\\'-> showString "\\\\"
  '\n' -> showString "\\n"
  '\t' -> showString "\\t"
  _ -> showChar s

prPrec :: Int -> Int -> Doc -> Doc
prPrec i j = if j < i then parenth else id

instance Print Integer where
  prt _ x = doc (shows x)

instance Print Double where
  prt _ x = doc (shows x)

instance Print AbsGrammar.UIdent where
  prt _ (AbsGrammar.UIdent i) = doc (showString i)

instance Print AbsGrammar.LIdent where
  prt _ (AbsGrammar.LIdent i) = doc (showString i)

instance Print AbsGrammar.NegChan where
  prt _ (AbsGrammar.NegChan i) = doc (showString i)

instance Print AbsGrammar.ReftIdent where
  prt _ (AbsGrammar.ReftIdent i) = doc (showString i)

instance Print AbsGrammar.DecInt where
  prt _ (AbsGrammar.DecInt i) = doc (showString i)

instance Print AbsGrammar.HexInt where
  prt _ (AbsGrammar.HexInt i) = doc (showString i)

instance Print AbsGrammar.OctInt where
  prt _ (AbsGrammar.OctInt i) = doc (showString i)

instance Print AbsGrammar.BinInt where
  prt _ (AbsGrammar.BinInt i) = doc (showString i)

instance Print AbsGrammar.Label where
  prt i e = case e of
    AbsGrammar.LabelLIdent lident -> prPrec i 0 (concatD [prt 0 lident])
    AbsGrammar.LabelDecInt decint -> prPrec i 0 (concatD [prt 0 decint])

instance Print AbsGrammar.AnyInt where
  prt i e = case e of
    AbsGrammar.AnyIntDec decint -> prPrec i 0 (concatD [prt 0 decint])
    AbsGrammar.AnyIntHex hexint -> prPrec i 0 (concatD [prt 0 hexint])
    AbsGrammar.AnyIntOct octint -> prPrec i 0 (concatD [prt 0 octint])
    AbsGrammar.AnyIntBin binint -> prPrec i 0 (concatD [prt 0 binint])

instance Print AbsGrammar.LSpc1LIdent where
  prt i e = case e of
    AbsGrammar.LSpc1LIdentCon lident lspclident -> prPrec i 0 (concatD [prt 0 lident, prt 0 lspclident])
    AbsGrammar.LSpc1LIdentNil lident -> prPrec i 0 (concatD [prt 0 lident])

instance Print AbsGrammar.LCom1LIdent where
  prt i e = case e of
    AbsGrammar.LCom1LIdentCon lident lcomlident -> prPrec i 0 (concatD [prt 0 lident, doc (showString ","), prt 0 lcomlident])
    AbsGrammar.LCom1LIdentNil lident -> prPrec i 0 (concatD [prt 0 lident])

instance Print AbsGrammar.BaseType where
  prt i e = case e of
    AbsGrammar.BTypeFun refinedtype1 refinedtype2 -> prPrec i 0 (concatD [prt 11 refinedtype1, doc (showString "->"), prt 0 refinedtype2])
    AbsGrammar.BTypeFunDep lident refinedtype1 refinedtype2 -> prPrec i 0 (concatD [prt 0 lident, doc (showString ":"), prt 11 refinedtype1, doc (showString "->"), prt 0 refinedtype2])
    AbsGrammar.BTypeVar lident -> prPrec i 1 (concatD [prt 0 lident])
    AbsGrammar.BTypeRecEmp -> prPrec i 1 (concatD [doc (showString "{}")])
    AbsGrammar.BTypeRecPoly lident -> prPrec i 1 (concatD [doc (showString "{"), prt 0 lident, doc (showString "}")])
    AbsGrammar.BTypeRec lcomrowtype -> prPrec i 1 (concatD [doc (showString "{"), prt 0 lcomrowtype, doc (showString "}")])
    AbsGrammar.BTypeRecExt lcomrowtype lident -> prPrec i 1 (concatD [doc (showString "{"), prt 0 lcomrowtype, doc (showString "|"), prt 0 lident, doc (showString "}")])
    AbsGrammar.BTypeTup lcomreftype -> prPrec i 1 (concatD [doc (showString "("), prt 0 lcomreftype, doc (showString ")")])
    AbsGrammar.BTypeArr refinedtype anyint -> prPrec i 1 (concatD [doc (showString "["), prt 0 refinedtype, doc (showString ";"), prt 0 anyint, doc (showString "]")])
    AbsGrammar.BTypeAlias alias -> prPrec i 2 (concatD [prt 0 alias])

instance Print AbsGrammar.LCom1RowType where
  prt i e = case e of
    AbsGrammar.LCom1RowTypeCon lident refinedtype lcomrowtype -> prPrec i 0 (concatD [prt 0 lident, doc (showString ":"), prt 0 refinedtype, doc (showString ","), prt 0 lcomrowtype])
    AbsGrammar.LCom1RowTypeNil lident refinedtype -> prPrec i 0 (concatD [prt 0 lident, doc (showString ":"), prt 0 refinedtype])

instance Print AbsGrammar.LCom1RefType where
  prt i e = case e of
    AbsGrammar.LCom1RefTypeCon refinedtype lcomreftype -> prPrec i 0 (concatD [prt 0 refinedtype, doc (showString ","), prt 0 lcomreftype])
    AbsGrammar.LCom1RefTypeNil refinedtype -> prPrec i 0 (concatD [prt 0 refinedtype])

instance Print AbsGrammar.LCom2RefType where
  prt i e = case e of
    AbsGrammar.LCom2RefTypeCon refinedtype lcomreftype -> prPrec i 0 (concatD [prt 0 refinedtype, doc (showString ","), prt 0 lcomreftype])
    AbsGrammar.LCom2RefTypeNil refinedtype1 refinedtype2 -> prPrec i 0 (concatD [prt 0 refinedtype1, doc (showString ","), prt 0 refinedtype2])

instance Print AbsGrammar.RefinedType where
  prt i e = case e of
    AbsGrammar.RTypeBase0 basetype -> prPrec i 0 (concatD [prt 0 basetype])
    AbsGrammar.RTypeQualFun lident basetype expr -> prPrec i 1 (concatD [doc (showString "(|"), prt 0 lident, doc (showString ":"), doc (showString "("), prt 10 basetype, doc (showString ")"), doc (showString "|"), prt 0 expr, doc (showString "|)")])
    AbsGrammar.RTypeQualBase lident basetype expr -> prPrec i 1 (concatD [doc (showString "(|"), prt 0 lident, doc (showString ":"), prt 11 basetype, doc (showString "|"), prt 0 expr, doc (showString "|)")])
    AbsGrammar.RTypeBase1 basetype -> prPrec i 1 (concatD [prt 1 basetype])
    AbsGrammar.RTypeBase2 basetype -> prPrec i 2 (concatD [prt 2 basetype])

instance Print AbsGrammar.Pattern where
  prt i e = case e of
    AbsGrammar.PatPar lbarpattern -> prPrec i 1 (concatD [prt 0 lbarpattern])
    AbsGrammar.PatVar lident -> prPrec i 2 (concatD [doc (showString "$"), prt 0 lident])
    AbsGrammar.PatVarAt lident pattern -> prPrec i 2 (concatD [doc (showString "$"), prt 0 lident, doc (showString "@"), prt 4 pattern])
    AbsGrammar.PatConArg lident lcompattern -> prPrec i 3 (concatD [prt 0 lident, doc (showString "("), prt 0 lcompattern, doc (showString ")")])
    AbsGrammar.PatCon lident -> prPrec i 3 (concatD [prt 0 lident])
    AbsGrammar.PatWild -> prPrec i 4 (concatD [doc (showString "_")])
    AbsGrammar.PatInt anyint -> prPrec i 4 (concatD [prt 0 anyint])
    AbsGrammar.PatNegInt decint -> prPrec i 4 (concatD [doc (showString "~"), prt 0 decint])
    AbsGrammar.PatRecEmp -> prPrec i 4 (concatD [doc (showString "{}")])
    AbsGrammar.PatRec lcomrecpat -> prPrec i 4 (concatD [doc (showString "{"), prt 0 lcomrecpat, doc (showString "}")])
    AbsGrammar.PatRecPoly lcomrecpat lident -> prPrec i 4 (concatD [doc (showString "{"), prt 0 lcomrecpat, doc (showString "|"), doc (showString "$"), prt 0 lident, doc (showString "}")])
    AbsGrammar.PatRecWild lcomrecpat -> prPrec i 4 (concatD [doc (showString "{"), prt 0 lcomrecpat, doc (showString "|"), doc (showString "_"), doc (showString "}")])
    AbsGrammar.PatTup lcompattern -> prPrec i 4 (concatD [doc (showString "("), prt 0 lcompattern, doc (showString ")")])
    AbsGrammar.PatArr lcompattern -> prPrec i 4 (concatD [doc (showString "["), prt 0 lcompattern, doc (showString "]")])

instance Print AbsGrammar.LCom1Pattern where
  prt i e = case e of
    AbsGrammar.LCom1PatternCon pattern lcompattern -> prPrec i 0 (concatD [prt 0 pattern, doc (showString ","), prt 0 lcompattern])
    AbsGrammar.LCom1PatternNil pattern -> prPrec i 0 (concatD [prt 0 pattern])

instance Print AbsGrammar.LCom2Pattern where
  prt i e = case e of
    AbsGrammar.LCom2PatternCon pattern lcompattern -> prPrec i 0 (concatD [prt 0 pattern, doc (showString ","), prt 0 lcompattern])
    AbsGrammar.LCom2PatternNil pattern1 pattern2 -> prPrec i 0 (concatD [prt 0 pattern1, doc (showString ","), prt 0 pattern2])

instance Print AbsGrammar.LBar2Pattern where
  prt i e = case e of
    AbsGrammar.LBar2PatternCon pattern lbarpattern -> prPrec i 0 (concatD [prt 2 pattern, doc (showString "||"), prt 0 lbarpattern])
    AbsGrammar.LBar2PatternNil pattern1 pattern2 -> prPrec i 0 (concatD [prt 2 pattern1, doc (showString "||"), prt 2 pattern2])

instance Print AbsGrammar.LCom1RecPat where
  prt i e = case e of
    AbsGrammar.LCom1RecPatCon lident pattern lcomrecpat -> prPrec i 0 (concatD [prt 0 lident, doc (showString "="), prt 0 pattern, doc (showString ","), prt 0 lcomrecpat])
    AbsGrammar.LCom1RecPatNil lident pattern -> prPrec i 0 (concatD [prt 0 lident, doc (showString "="), prt 0 pattern])

instance Print AbsGrammar.Expr where
  prt i e = case e of
    AbsGrammar.EAbs lcompattern expr -> prPrec i 101 (concatD [doc (showString "\\("), prt 0 lcompattern, doc (showString ")"), doc (showString "->"), prt 0 expr])
    AbsGrammar.EAbsCase lsemicase -> prPrec i 102 (concatD [doc (showString "\\case"), doc (showString "{"), prt 0 lsemicase, doc (showString "}")])
    AbsGrammar.ECase expr lsemicase -> prPrec i 201 (concatD [doc (showString "case"), prt 0 expr, doc (showString "of"), doc (showString "{"), prt 0 lsemicase, doc (showString "}")])
    AbsGrammar.ELet lsemilet expr -> prPrec i 202 (concatD [doc (showString "let"), doc (showString "{"), prt 0 lsemilet, doc (showString "}"), doc (showString "in"), prt 2 expr])
    AbsGrammar.EIf expr1 expr2 expr3 -> prPrec i 301 (concatD [doc (showString "if"), prt 0 expr1, doc (showString "then"), prt 3 expr2, doc (showString "else"), prt 3 expr3])
    AbsGrammar.EMultiIf lsemimulti -> prPrec i 302 (concatD [doc (showString "if"), doc (showString "{"), prt 0 lsemimulti, doc (showString "}")])
    AbsGrammar.EIff expr1 expr2 -> prPrec i 4 (concatD [prt 5 expr1, doc (showString "<->"), prt 4 expr2])
    AbsGrammar.EImp expr1 expr2 -> prPrec i 5 (concatD [prt 6 expr1, doc (showString "-->"), prt 6 expr2])
    AbsGrammar.ELogOr expr1 expr2 -> prPrec i 6 (concatD [prt 7 expr1, doc (showString "||"), prt 6 expr2])
    AbsGrammar.ELogAnd expr1 expr2 -> prPrec i 7 (concatD [prt 8 expr1, doc (showString "&&"), prt 7 expr2])
    AbsGrammar.EEq expr1 expr2 -> prPrec i 8 (concatD [prt 9 expr1, doc (showString "=="), prt 9 expr2])
    AbsGrammar.ENotEq expr1 expr2 -> prPrec i 8 (concatD [prt 9 expr1, doc (showString "!="), prt 9 expr2])
    AbsGrammar.EGtEq expr1 expr2 -> prPrec i 8 (concatD [prt 9 expr1, doc (showString ">="), prt 9 expr2])
    AbsGrammar.ELtEq expr1 expr2 -> prPrec i 8 (concatD [prt 9 expr1, doc (showString "<="), prt 9 expr2])
    AbsGrammar.EGt expr1 expr2 -> prPrec i 8 (concatD [prt 9 expr1, doc (showString ">"), prt 9 expr2])
    AbsGrammar.ELt expr1 expr2 -> prPrec i 8 (concatD [prt 9 expr1, doc (showString "<"), prt 9 expr2])
    AbsGrammar.EPlus expr1 expr2 -> prPrec i 9 (concatD [prt 10 expr1, doc (showString "+"), prt 9 expr2])
    AbsGrammar.EMinus expr1 expr2 -> prPrec i 9 (concatD [prt 10 expr1, doc (showString "-"), prt 9 expr2])
    AbsGrammar.ETimes expr1 expr2 -> prPrec i 10 (concatD [prt 11 expr1, doc (showString "*"), prt 10 expr2])
    AbsGrammar.EDiv expr1 expr2 -> prPrec i 10 (concatD [prt 11 expr1, doc (showString "/"), prt 10 expr2])
    AbsGrammar.EMod expr1 expr2 -> prPrec i 10 (concatD [prt 11 expr1, doc (showString "%"), prt 10 expr2])
    AbsGrammar.ELogNot expr -> prPrec i 11 (concatD [doc (showString "!"), prt 11 expr])
    AbsGrammar.ENegate expr -> prPrec i 11 (concatD [doc (showString "~"), prt 11 expr])
    AbsGrammar.ERecSel expr label -> prPrec i 1201 (concatD [prt 12 expr, doc (showString "."), prt 0 label])
    AbsGrammar.ERecRem expr label -> prPrec i 1201 (concatD [prt 12 expr, doc (showString "\\"), prt 0 label])
    AbsGrammar.EInt anyint -> prPrec i 1202 (concatD [prt 0 anyint])
    AbsGrammar.EVar lident -> prPrec i 1202 (concatD [prt 0 lident])
    AbsGrammar.EReftVar reftident -> prPrec i 1202 (concatD [prt 0 reftident])
    AbsGrammar.EApp expr lcomexpr -> prPrec i 1202 (concatD [prt 12 expr, doc (showString "("), prt 0 lcomexpr, doc (showString ")")])
    AbsGrammar.ETup lcomexpr -> prPrec i 1202 (concatD [doc (showString "("), prt 0 lcomexpr, doc (showString ")")])
    AbsGrammar.EArr lcomexpr -> prPrec i 1202 (concatD [doc (showString "["), prt 0 lcomexpr, doc (showString "]")])
    AbsGrammar.ERecEmpt -> prPrec i 1203 (concatD [doc (showString "{}")])
    AbsGrammar.ERec lcomrecexpr -> prPrec i 1203 (concatD [doc (showString "{"), prt 0 lcomrecexpr, doc (showString "}")])
    AbsGrammar.ERecPoly lcomrecexpr expr -> prPrec i 1203 (concatD [doc (showString "{"), prt 0 lcomrecexpr, doc (showString "|"), prt 0 expr, doc (showString "}")])

instance Print AbsGrammar.LSemi1Case where
  prt i e = case e of
    AbsGrammar.LSemi1CaseCon pattern expr lsemicase -> prPrec i 0 (concatD [prt 0 pattern, doc (showString "->"), prt 0 expr, doc (showString ";"), prt 0 lsemicase])
    AbsGrammar.LSemi1CaseNil pattern expr -> prPrec i 0 (concatD [prt 0 pattern, doc (showString "->"), prt 0 expr])

instance Print AbsGrammar.LSemi1Let where
  prt i e = case e of
    AbsGrammar.LSemi1LetCon pattern expr lsemilet -> prPrec i 0 (concatD [prt 0 pattern, doc (showString "="), prt 0 expr, doc (showString ";"), prt 0 lsemilet])
    AbsGrammar.LSemi1LetNil pattern expr -> prPrec i 0 (concatD [prt 0 pattern, doc (showString "="), prt 0 expr])

instance Print AbsGrammar.LSemi1Multi where
  prt i e = case e of
    AbsGrammar.LSemi1MultiCon expr1 expr2 lsemimulti -> prPrec i 0 (concatD [prt 2 expr1, doc (showString "->"), prt 0 expr2, doc (showString ";"), prt 0 lsemimulti])
    AbsGrammar.LSemi1MultiNil expr1 expr2 -> prPrec i 0 (concatD [prt 2 expr1, doc (showString "->"), prt 0 expr2])

instance Print AbsGrammar.LCom1Expr where
  prt i e = case e of
    AbsGrammar.LCom1ExprCon expr lcomexpr -> prPrec i 0 (concatD [prt 0 expr, doc (showString ","), prt 0 lcomexpr])
    AbsGrammar.LCom1ExprNil expr -> prPrec i 0 (concatD [prt 0 expr])

instance Print AbsGrammar.LCom2Expr where
  prt i e = case e of
    AbsGrammar.LCom2ExprCon expr lcomexpr -> prPrec i 0 (concatD [prt 0 expr, doc (showString ","), prt 0 lcomexpr])
    AbsGrammar.LCom2ExprNil expr1 expr2 -> prPrec i 0 (concatD [prt 0 expr1, doc (showString ","), prt 0 expr2])

instance Print AbsGrammar.LCom1RecExpr where
  prt i e = case e of
    AbsGrammar.LCom1RecExtendCon lident expr lcomrecexpr -> prPrec i 0 (concatD [prt 0 lident, doc (showString "="), prt 0 expr, doc (showString ","), prt 0 lcomrecexpr])
    AbsGrammar.LCom1RecRenameCon lident1 lident2 lcomrecexpr -> prPrec i 0 (concatD [prt 0 lident1, doc (showString "<-"), prt 0 lident2, doc (showString ","), prt 0 lcomrecexpr])
    AbsGrammar.LCom1RecUpdateCon lident expr lcomrecexpr -> prPrec i 0 (concatD [prt 0 lident, doc (showString ":="), prt 0 expr, doc (showString ","), prt 0 lcomrecexpr])
    AbsGrammar.LCom1RecExtendNil lident expr -> prPrec i 0 (concatD [prt 0 lident, doc (showString "="), prt 0 expr])
    AbsGrammar.LCom1RecRenameNil lident1 lident2 -> prPrec i 0 (concatD [prt 0 lident1, doc (showString "<-"), prt 0 lident2])
    AbsGrammar.LCom1RecUpdateNil lident expr -> prPrec i 0 (concatD [prt 0 lident, doc (showString ":="), prt 0 expr])

instance Print AbsGrammar.AnyType where
  prt i e = case e of
    AbsGrammar.AnyTypeRType refinedtype -> prPrec i 0 (concatD [prt 99 refinedtype])
    AbsGrammar.AnyTypeSess session -> prPrec i 0 (concatD [prt 99 session])
    AbsGrammar.AnyTypeAlias alias -> prPrec i 0 (concatD [prt 0 alias])

instance Print AbsGrammar.LCom1AnyType where
  prt i e = case e of
    AbsGrammar.LCom1AnyTypeCon anytype lcomanytype -> prPrec i 0 (concatD [prt 0 anytype, doc (showString ","), prt 0 lcomanytype])
    AbsGrammar.LCom1AnyTypeNil anytype -> prPrec i 0 (concatD [prt 0 anytype])

instance Print AbsGrammar.Alias where
  prt i e = case e of
    AbsGrammar.AliasNoParam uident -> prPrec i 0 (concatD [prt 0 uident])
    AbsGrammar.AliasParam uident lcomanytype maybelcomexpr -> prPrec i 0 (concatD [prt 0 uident, doc (showString "("), prt 0 lcomanytype, prt 0 maybelcomexpr, doc (showString ")")])

instance Print AbsGrammar.MaybeLCom1Expr where
  prt i e = case e of
    AbsGrammar.MaybeLCom1ExprJust lcomexpr -> prPrec i 0 (concatD [doc (showString ";"), prt 0 lcomexpr])
    AbsGrammar.MaybeLCom1ExprNothing -> prPrec i 0 (concatD [])

instance Print AbsGrammar.Session where
  prt i e = case e of
    AbsGrammar.SessRec uident session -> prPrec i 0 (concatD [doc (showString "coind"), prt 0 uident, doc (showString "."), prt 12 session])
    AbsGrammar.SessGet anytype session -> prPrec i 1 (concatD [doc (showString "?"), doc (showString "["), prt 0 anytype, doc (showString "]"), prt 0 session])
    AbsGrammar.SessPut anytype session -> prPrec i 1 (concatD [doc (showString "!"), doc (showString "["), prt 0 anytype, doc (showString "]"), prt 0 session])
    AbsGrammar.SessSel lcomschoice -> prPrec i 1 (concatD [doc (showString "+"), doc (showString "["), prt 0 lcomschoice, doc (showString "]")])
    AbsGrammar.SessCho lcomschoice -> prPrec i 1 (concatD [doc (showString "&"), doc (showString "["), prt 0 lcomschoice, doc (showString "]")])
    AbsGrammar.SessDual session -> prPrec i 1 (concatD [doc (showString "dual"), prt 2 session])
    AbsGrammar.SessEnd -> prPrec i 1 (concatD [])
    AbsGrammar.SessAlias alias -> prPrec i 2 (concatD [prt 0 alias])

instance Print AbsGrammar.LCom1SChoice where
  prt i e = case e of
    AbsGrammar.LCom1SChoiceCon lident session lcomschoice -> prPrec i 0 (concatD [prt 0 lident, doc (showString "->"), prt 0 session, doc (showString ","), prt 0 lcomschoice])
    AbsGrammar.LCom1SChoiceNil lident session -> prPrec i 0 (concatD [prt 0 lident, doc (showString "->"), prt 0 session])

instance Print AbsGrammar.ChanExp where
  prt i e = case e of
    AbsGrammar.ChanExprNeg negchan -> prPrec i 0 (concatD [prt 0 negchan])
    AbsGrammar.ChanExprExp expr -> prPrec i 0 (concatD [prt 0 expr])

instance Print AbsGrammar.Chan where
  prt i e = case e of
    AbsGrammar.ChanPos lident -> prPrec i 0 (concatD [prt 0 lident])
    AbsGrammar.ChanNeg negchan -> prPrec i 0 (concatD [prt 0 negchan])

instance Print AbsGrammar.Proc where
  prt i e = case e of
    AbsGrammar.ProcPar lbarparproc -> prPrec i 1 (concatD [doc (showString "{"), prt 0 lbarparproc, doc (showString "}")])
    AbsGrammar.ProcLet pattern expr proc -> prPrec i 2 (concatD [doc (showString "let"), prt 0 pattern, doc (showString "="), prt 0 expr, prt 0 proc])
    AbsGrammar.ProcNew lident session proc -> prPrec i 2 (concatD [doc (showString "new"), prt 0 lident, doc (showString ":"), prt 0 session, prt 0 proc])
    AbsGrammar.ProcGet chan pattern proc -> prPrec i 2 (concatD [prt 0 chan, doc (showString "->"), prt 0 pattern, prt 0 proc])
    AbsGrammar.ProcPut chan chanexp proc -> prPrec i 2 (concatD [prt 0 chan, doc (showString "<-"), prt 0 chanexp, prt 0 proc])
    AbsGrammar.ProcSel chan lident proc -> prPrec i 2 (concatD [prt 0 chan, doc (showString "select"), prt 0 lident, prt 0 proc])
    AbsGrammar.ProcChoice chan lcompchoice -> prPrec i 2 (concatD [prt 0 chan, doc (showString "cases"), doc (showString "{"), prt 0 lcompchoice, doc (showString "}")])
    AbsGrammar.ProcRec lident lcomrecproc proc -> prPrec i 2 (concatD [doc (showString "corec"), prt 0 lident, doc (showString "("), prt 0 lcomrecproc, doc (showString ")"), prt 0 proc])
    AbsGrammar.ProcNamed lident lcomchanexp -> prPrec i 2 (concatD [prt 0 lident, doc (showString "("), prt 0 lcomchanexp, doc (showString ")")])
    AbsGrammar.ProcFwd chan1 chan2 -> prPrec i 2 (concatD [prt 0 chan1, doc (showString "<->"), prt 0 chan2])
    AbsGrammar.ProcEnd -> prPrec i 2 (concatD [])

instance Print AbsGrammar.LCom1ChanExp where
  prt i e = case e of
    AbsGrammar.LCom1ChanExpCon chanexp lcomchanexp -> prPrec i 0 (concatD [prt 0 chanexp, doc (showString ","), prt 0 lcomchanexp])
    AbsGrammar.LCom1ChanExpNil chanexp -> prPrec i 0 (concatD [prt 0 chanexp])

instance Print AbsGrammar.LCom1PChoice where
  prt i e = case e of
    AbsGrammar.LCom1PChoiceCon lident proc lcompchoice -> prPrec i 0 (concatD [prt 0 lident, doc (showString "->"), prt 0 proc, doc (showString ","), prt 0 lcompchoice])
    AbsGrammar.LCom1PChoiceNil lident proc -> prPrec i 0 (concatD [prt 0 lident, doc (showString "->"), prt 0 proc])

instance Print AbsGrammar.LCom1RecProc where
  prt i e = case e of
    AbsGrammar.LCom1RecProcCon pattern chanexp lcomrecproc -> prPrec i 0 (concatD [prt 0 pattern, doc (showString "="), prt 0 chanexp, doc (showString ","), prt 0 lcomrecproc])
    AbsGrammar.LCom1RecProcNil pattern chanexp -> prPrec i 0 (concatD [prt 0 pattern, doc (showString "="), prt 0 chanexp])

instance Print AbsGrammar.LBar2ParProc where
  prt i e = case e of
    AbsGrammar.LBar2ParProcCon proc lbarparproc -> prPrec i 0 (concatD [prt 2 proc, doc (showString "|"), prt 0 lbarparproc])
    AbsGrammar.LBar2ParProcNil proc1 proc2 -> prPrec i 0 (concatD [prt 2 proc1, doc (showString "|"), prt 2 proc2])

instance Print AbsGrammar.DataCon where
  prt i e = case e of
    AbsGrammar.DataConEmpt lident -> prPrec i 0 (concatD [prt 0 lident])
    AbsGrammar.DataConArgs lident lcomreftype -> prPrec i 0 (concatD [prt 0 lident, doc (showString "("), prt 0 lcomreftype, doc (showString ")")])

instance Print AbsGrammar.LBar1DataCon where
  prt i e = case e of
    AbsGrammar.LBar1DataConCon datacon lbardatacon -> prPrec i 0 (concatD [prt 0 datacon, doc (showString "|"), prt 0 lbardatacon])
    AbsGrammar.LBar1DataConNil datacon -> prPrec i 0 (concatD [prt 0 datacon])

instance Print AbsGrammar.TScheme where
  prt i e = case e of
    AbsGrammar.TPoly lspclident refinedtype -> prPrec i 0 (concatD [doc (showString "forall"), prt 0 lspclident, doc (showString "."), prt 0 refinedtype])
    AbsGrammar.TMono refinedtype -> prPrec i 0 (concatD [prt 0 refinedtype])

instance Print AbsGrammar.Top where
  prt i e = case e of
    AbsGrammar.TopTypeDef lident tscheme -> prPrec i 0 (concatD [prt 0 lident, doc (showString ":"), prt 0 tscheme])
    AbsGrammar.TopType uident anytype -> prPrec i 0 (concatD [doc (showString "type"), prt 0 uident, doc (showString "="), prt 0 anytype])
    AbsGrammar.TopTypeParam uident lcomlident anytype -> prPrec i 0 (concatD [doc (showString "type"), prt 0 uident, doc (showString "("), prt 0 lcomlident, doc (showString ")"), doc (showString "="), prt 0 anytype])
    AbsGrammar.TopData uident lbardatacon -> prPrec i 0 (concatD [doc (showString "data"), prt 0 uident, doc (showString "="), prt 0 lbardatacon])
    AbsGrammar.TopDataParam uident lcomlident lbardatacon -> prPrec i 0 (concatD [doc (showString "data"), prt 0 uident, doc (showString "("), prt 0 lcomlident, doc (showString ")"), doc (showString "="), prt 0 lbardatacon])
    AbsGrammar.TopExpr lident expr -> prPrec i 0 (concatD [prt 0 lident, doc (showString "="), prt 0 expr])
    AbsGrammar.TopFunc lident lcompattern expr -> prPrec i 0 (concatD [prt 0 lident, doc (showString "("), prt 0 lcompattern, doc (showString ")"), doc (showString "="), prt 0 expr])
    AbsGrammar.TopPat pattern expr -> prPrec i 0 (concatD [doc (showString "let"), prt 0 pattern, doc (showString "="), prt 0 expr])
    AbsGrammar.TopProc lident lcompattern proc -> prPrec i 0 (concatD [doc (showString "proc"), prt 0 lident, doc (showString "("), prt 0 lcompattern, doc (showString ")"), doc (showString "="), prt 0 proc])

instance Print AbsGrammar.LTop where
  prt i e = case e of
    AbsGrammar.LTopCon top ltop -> prPrec i 0 (concatD [prt 0 top, doc (showString ";"), prt 0 ltop])
    AbsGrammar.LTopNil top -> prPrec i 0 (concatD [prt 0 top, doc (showString ";")])

