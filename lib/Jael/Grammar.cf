-- Tokens

token UIdent (upper (letter | digit | '_')*) ;
token LIdent (lower (letter | digit | '_')*) ;
token LScopedIdent (lower (letter | digit | '_' | {"::"})*) ;
token DecInt ('0' | ('~'? ["123456789"] digit*)) ;
token HexInt ({"0x"} ["0123456789abcdefABCDEF"]+) ;
token OctInt ({"0o"} ["01234567"]+) ;
token BinInt ({"0b"} ["01"]+) ;

rules AnyInt ::= DecInt | HexInt | OctInt | BinInt ;

-- Sequential Types

TNamedParam_. TNamedParam ::= Type ;
separator TNamedParam "," ;

TNamedNoParam. TNamedParams ::= ;
TNamedParams_. TNamedParams ::= "(" [TNamedParam] ")" ;

TupArg_.    TupArg ::= Type ;
separator   nonempty TupArg "," ;

TBit.       Type ::= "Bit" ;
TBool.      Type ::= "Bool" ;
TBuffer.    Type ::= "Buffer" ;
TInt.       Type ::= "Int"    ;
TUnit.      Type ::= "Void" ;
TTup.       Type ::= "(" TupArg "," [TupArg] ")";
TNamed.     Type ::= UIdent TNamedParams ;
TTVar.      Type ::= LIdent ;

-- Session Types

SessChoice_. SessChoice ::= LIdent "=>" Session1 ;
separator nonempty SessChoice "," ;

SessTy.   SessOrTy ::= Type ;
SessSess. SessOrTy ::= Session1 ;

SessRec.  Session1 ::= "rec" UIdent "." Session2 ;

SessGet.  Session2 ::= "?" "[" SessOrTy "]" Session1 ;
SessPut.  Session2 ::= "!" "[" SessOrTy "]" Session1 ;
SessSel.  Session2 ::= "+" "[" [SessChoice] "]" ;
SessCho.  Session2 ::= "&" "[" [SessChoice] "]" ;

SessEnd. Session3 ::= ;
-- recursion variable surrounded in <> to distinguish it from TNamed in
-- SessGet and SessPut
SessVar.     Session3 ::= "<" UIdent ">" ;
SessVarDual. Session3 ::= "<" "dual" UIdent ">" ;

coercions Session 3 ;

-- Enums

TEnumElem_. TEnumElem ::= LIdent Type ;
separator nonempty TEnumElem "," ;

TEnumDef_.  TEnumDef   ::= "{" [TEnumElem] "}" ;

-- Structs

---- Annotations
TStructAnnPad.   TStructAnn ::= "pad"   AnyInt ;
TStructAnnAlign. TStructAnn ::= "align" AnyInt ;
separator nonempty TStructAnn "," ;

---- A single element list collecting several annotations
TStructAnnCol_. TStructAnnCol ::= "[" [TStructAnn] "]" ;

TStructElement_.   TStructElement ::=                LIdent ":" Type ;
TStructElementAnn. TStructElement ::= TStructAnnCol LIdent ":" Type ;
separator nonempty TStructElement "," ;

TStructDef_. TStructDef ::= "{" [TStructElement] "}" ;

-- Expressions

ELetIdent_.  ELetIdent ::= LIdent "=" Expr ;
terminator   ELetIdent ";" ;

ELetExpr_.   ELetExpr ::= [ELetIdent] Expr ;

EAppArg_.     EAppArg ::= Expr ;
separator    nonempty EAppArg "," ;

ETupArg_.    ETupArg ::= Expr ;
separator    nonempty ETupArg "," ;

----- Begin operators -----

-- Haskell precedence 2
ELogOr.     Expr3 ::= Expr4 "||" Expr3 ;

-- Haskell precedence 3
ELogAnd.    Expr4 ::= Expr5 "&&" Expr4 ;

-- Haskell precedence 4
EEq.        Expr5 ::= Expr6 "==" Expr6 ;
ENotEq.     Expr5 ::= Expr6 "!=" Expr6 ;
EGtEq.      Expr5 ::= Expr6 ">=" Expr6 ;
ELtEq.      Expr5 ::= Expr6 "<=" Expr6 ;
EGt.        Expr5 ::= Expr6 ">"  Expr6 ;
ELt.        Expr5 ::= Expr6 "<"  Expr6 ;
-- elem, notElem

-- Haskell precedence 5
-- cons, append

-- Haskell precedence 6
EPlus.      Expr7 ::= Expr7 "+" Expr8 ;
EMinus.     Expr7 ::= Expr7 "-" Expr8 ;

-- Haskell precedence 7
ETimes.     Expr8 ::= Expr8 "*" Expr9 ;
EDiv.       Expr8 ::= Expr8 "/" Expr9 ;
EMod.       Expr8 ::= Expr8 "%" Expr9 ;
-- rem, quot, div

-- Haskell precedence 8
-- Power operators
EBitCat.    Expr9  ::= Expr10 "#" Expr9 ;

-- Haskell precedence 9

ELogNot.    Expr12 ::= "!" Expr12 ;

----- End operators -----

EIf.        Expr13 ::= "if" Expr "{" ELetExpr "}" "else" "{" ELetExpr "}" ;

ETrue.      Expr16 ::= "true" ;
EFalse.     Expr16 ::= "false" ;
EInt.       Expr16 ::= DecInt ;
EVar.       Expr16 ::= LIdent ;
EApp.       Expr16 ::= LIdent       "(" [EAppArg] ")" ;
EAppScoped. Expr16 ::= LScopedIdent "(" [EAppArg] ")" ;
EUnit.      Expr16 ::= "void" ;
ETup.       Expr16 ::= "(" ETupArg "," [ETupArg] ")" ;

coercions    Expr 16 ;

-- Process grammar

-- Builtin channels can have "::" in their name
ChanNotScoped. Chan ::= "^" LIdent ;
ChanScoped.    Chan ::= "^" LScopedIdent ;

ProcNew.     Proc1 ::= "new" "(" "^" LIdent "," "^" LIdent ")"
  ":" Session   ";" Proc1 ;

ProcLet.     Proc1 ::= LIdent "="     Expr      ";" Proc1 ;
ProcGetExpr. Proc1 ::= Chan  "->"     LIdent    ";" Proc1 ;
ProcGetChan. Proc1 ::= Chan  "->" "^" LIdent    ";" Proc1 ;
ProcGetIgn.  Proc1 ::= Chan  "->"     "_"       ";" Proc1 ;

ProcPutExpr. Proc1 ::= Chan  "<-"     Expr      ";" Proc1 ;
ProcPutChan. Proc1 ::= Chan  "<-"     Chan      ";" Proc1 ;

ProcSel.     Proc1 ::= Chan "select"  LIdent    ";" Proc1 ;

ConcChoice_. ConcChoice ::= LIdent "=>" Proc ;
separator nonempty ConcChoice "," ;

ProcCho.     Proc1 ::= Chan "case"
  "{"
    [ ConcChoice ]
  "}" ;

RecInitializerExpr. RecInitializer ::=     LIdent "=" Expr ;
RecInitializerChan. RecInitializer ::= "^" LIdent "=" Chan ;
separator nonempty RecInitializer "," ;

ProcRec.   Proc1 ::= "rec" UIdent "(" [RecInitializer] ")"
  "{" Proc "}" ;

ProcParamExpr. ProcParam ::= Expr ;
ProcParamChan. ProcParam ::= Chan ;
separator ProcParam "," ;

ProcNamed. Proc1 ::= UIdent "(" [ProcParam] ")" ;
ProcFwd.   Proc1 ::= Chan "<->" Chan ;
ProcInact. Proc1 ::= ;

ParElem_.  ParElem ::= Proc1 ;
separator nonempty ParElem "|" ;

ProcPar.  Proc2 ::= "(" ParElem "|" [ParElem] ")" ;

coercions Proc 2 ;

-- Top level grammar

TDefStruct. TypeDef ::= "struct"   UIdent TStructDef ;
TDefEnum.   TypeDef ::= "enum"     UIdent TEnumDef ;
TDefProto.  TypeDef ::= "protocol" UIdent ":" Session ";" ;
TDefArea.   TypeDef ::= "area"     UIdent "@" AnyInt ":" UIdent ";" ;

FuncArg_.  FuncArg  ::= LIdent ":" Type ;
separator nonempty FuncArg "," ;

ProcArgSess.  ProcArg ::= "^" LIdent ":" Session ;
ProcArgType.  ProcArg ::=     LIdent ":" Type ;
separator ProcArg "," ;

Global_.  Global  ::= LIdent "=" Expr ";" ;
Func_.    Func    ::= "func" LIdent "(" [FuncArg] ")" ":" Type
  "{"
    Expr
  "}" ;

ProcDef_. ProcDef ::= "proc" UIdent "(" [ProcArg] ")"
  "{"
    Proc
  "}" ;

rules TopDef ::= TypeDef | Global | Func | ProcDef ;
terminator  TopDef "" ;

Prog_.      Prog ::= [TopDef] ;

comment "//" ;

-- Only export nessecary parsers.
entrypoints Prog, TopDef, TypeDef, Type, Session, Expr, Proc, ProcArg ;

