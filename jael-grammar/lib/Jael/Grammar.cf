-- Tokens

position token UIdent (upper (letter | digit | '_')*) ;
position token LIdent (lower (letter | digit | '_')*) ;
position token LScopedIdent (lower (letter | digit | '_' | {"::"})*) ;
position token DecInt ('0' | ('~'? ["123456789"] digit*)) ;
position token HexInt ({"0x"} ["0123456789abcdefABCDEF"]+) ;
position token OctInt ({"0o"} ["01234567"]+) ;
position token BinInt ({"0b"} ["01"]+) ;

rules AnyInt ::= DecInt | HexInt | OctInt | BinInt ;

-- Sequential Types

rules CommaSepType ::= Type ;
separator nonempty CommaSepType "," ;

TNamedParamsEmpty. TNamedParams ::= ;
TNamedParamsList.  TNamedParams ::= "(" [CommaSepType] ")" ;

TBit.       BType ::= "BitField" ;
TBool.      BType ::= "Bool" ;
TInt.       BType ::= "Int"    ;
TUnit.      BType ::= "Void" ;
TTup.       BType ::= "(" Type "," [CommaSepType] ")";
TNamed.     BType ::= UIdent TNamedParams ;

-- liquid types
-- See https://ucsd-progsys.github.io/liquidhaskell-tutorial/02-logic.html
-- and the definition of Expr at
-- https://github.com/ucsd-progsys/liquid-fixpoint/blob/master/src/Language/Fixpoint/Types/Refinements.hs

QPredIff. QPred1 ::= QPred2 "<=>" QPred2 ;

QPredImp. QPred2 ::= QPred3 "==>" QPred3 ;

QPredOr.  QPred3 ::= QPred4 "||" QPred4 ;

QPredAnd. QPred4 ::= QPred5 "&&" QPred5 ;

QPredNot. QPred5 ::= "!" QPred6 ;

QPredTrue.  QPred6 ::= "true" ;
QPredFalse. QPred6 ::= "false" ;
QPredAtom.  QPred6 ::= QExpr QRel QExpr ;

coercions QPred 6 ;

QRelEq. QRel ::= "==" ;
QRelNe. QRel ::= "!=" ;
QRelGe. QRel ::= ">=" ;
QRelLe. QRel ::= "<=" ;
QRelGt. QRel ::= ">" ;
QRelLt. QRel ::= "<" ;

QExprAdd. QExpr1 ::= QExpr1 "+" QExpr2 ;
QExprSub. QExpr1 ::= QExpr1 "-" QExpr2 ;

QExprMul. QExpr2 ::= AnyInt "*" QExpr3 ;

QExprInt. QExpr3 ::= AnyInt ;
QExprVar. QExpr3 ::= LIdent ;
QExprApp. QExpr3 ::= LIdent "(" [CommaSepQExpr] ")" ;

coercions QExpr 3 ;

rules CommaSepQExpr ::= QExpr ;
separator nonempty CommaSepQExpr "," ;

rules QType ::= LIdent ":" BType "|" QPred ;

TypeB. Type ::= BType ;
TypeQ. Type ::= QType ;
TypeV. Type ::= LIdent ;

-- Session Types

rules SessChoice ::= LIdent "=>" Session1 ;
separator nonempty SessChoice "," ;

SessTy.   SessOrTy ::= Type ;
SessSess. SessOrTy ::= Session1 ;

SessRec.  Session1 ::= "rec" UIdent "." Session2 ;

SessGet.  Session2 ::= "?" "[" SessOrTy "]" Session1 ;
SessPut.  Session2 ::= "!" "[" SessOrTy "]" Session1 ;
SessSel.  Session2 ::= "+" "[" [SessChoice] "]" ;
SessCho.  Session2 ::= "&" "[" [SessChoice] "]" ;

SessEnd. Session3 ::= ;
-- recursion variable surrounded in <> to distinguish it from TNamed in
-- SessGet and SessPut
SessVar.     Session3 ::= "<" UIdent ">" ;
SessVarDual. Session3 ::= "<" "dual" UIdent ">" ;

coercions Session 3 ;

-- Expressions

rules ELetElem ::= LIdent "=" Expr ;
terminator   ELetElem ";" ;

rules ELetExpr ::= [ELetElem] Expr ;

rules CommaSepExpr ::= Expr ;
separator nonempty CommaSepExpr "," ;

----- Begin operators -----

-- Haskell precedence 2
ELogOr.     Expr3 ::= Expr4 "||" Expr3 ;

-- Haskell precedence 3
ELogAnd.    Expr4 ::= Expr5 "&&" Expr4 ;

-- Haskell precedence 4
EEq.        Expr5 ::= Expr6 "==" Expr6 ;
ENotEq.     Expr5 ::= Expr6 "!=" Expr6 ;
EGtEq.      Expr5 ::= Expr6 ">=" Expr6 ;
ELtEq.      Expr5 ::= Expr6 "<=" Expr6 ;
EGt.        Expr5 ::= Expr6 ">"  Expr6 ;
ELt.        Expr5 ::= Expr6 "<"  Expr6 ;
-- elem, notElem

-- Haskell precedence 5
-- cons, append

-- Haskell precedence 6
EPlus.      Expr7 ::= Expr7 "+" Expr8 ;
EMinus.     Expr7 ::= Expr7 "-" Expr8 ;

-- Haskell precedence 7
ETimes.     Expr8 ::= Expr8 "*" Expr9 ;
EDiv.       Expr8 ::= Expr8 "/" Expr9 ;
EMod.       Expr8 ::= Expr8 "%" Expr9 ;
-- rem, quot, div

-- Haskell precedence 8
-- Power operators
EBitCat.    Expr9  ::= Expr10 "#" Expr9 ;

-- Haskell precedence 9

ELogNot.    Expr12 ::= "!" Expr12 ;

----- End operators -----

EIf.        Expr13 ::= "if" Expr "{" ELetExpr "}" "else" "{" ELetExpr "}" ;

ETrue.      Expr16 ::= "true" ;
EFalse.     Expr16 ::= "false" ;
EInt.       Expr16 ::= DecInt ;
EVar.       Expr16 ::= LIdent ;
EApp.       Expr16 ::= LIdent       "(" [CommaSepExpr] ")" ;
EAppScoped. Expr16 ::= LScopedIdent "(" [CommaSepExpr] ")" ;
EUnit.      Expr16 ::= "void" ;
ETup.       Expr16 ::= "(" CommaSepExpr "," [CommaSepExpr] ")" ;

coercions    Expr 16 ;

-- Process grammar

-- Builtin channels can have "::" in their name
ChanNotScoped. Chan ::= "^" LIdent ;
ChanScoped.    Chan ::= "^" LScopedIdent ;

ProcNew.     Proc1 ::= "new" "(" "^" LIdent "," "^" LIdent ")"
  ":" Session   ";" Proc1 ;

ProcLet.     Proc1 ::= LIdent "="     Expr      ";" Proc1 ;
ProcGetExpr. Proc1 ::= Chan  "->"     LIdent    ";" Proc1 ;
ProcGetChan. Proc1 ::= Chan  "->" "^" LIdent    ";" Proc1 ;
ProcGetIgn.  Proc1 ::= Chan  "->"     "_"       ";" Proc1 ;

ProcPutExpr. Proc1 ::= Chan  "<-"     Expr      ";" Proc1 ;
ProcPutChan. Proc1 ::= Chan  "<-"     Chan      ";" Proc1 ;

ProcSel.     Proc1 ::= Chan "select"  LIdent    ";" Proc1 ;

rules ConcChoice ::= LIdent "=>" Proc ;
separator nonempty ConcChoice "," ;

ProcCho.     Proc1 ::= Chan "case"
  "{"
    [ ConcChoice ]
  "}" ;

RecInitializerExpr. RecInitializer ::=     LIdent "=" Expr ;
RecInitializerChan. RecInitializer ::= "^" LIdent "=" Chan ;
separator nonempty RecInitializer "," ;

ProcRec.   Proc1 ::= "rec" UIdent "(" [RecInitializer] ")"
  "{" Proc "}" ;

ProcParamExpr. ProcParam ::= Expr ;
ProcParamChan. ProcParam ::= Chan ;
separator ProcParam "," ;

ProcNamed. Proc1 ::= UIdent "(" [ProcParam] ")" ;
ProcFwd.   Proc1 ::= Chan "<->" Chan ;
ProcInact. Proc1 ::= ;

rules ParElem ::= Proc1 ;
separator nonempty ParElem "|" ;

ProcPar.  Proc2 ::= "(" ParElem "|" [ParElem] ")" ;

coercions Proc 2 ;

-- Top level grammar

TDefProto.  TypeDef ::= "protocol" UIdent ":" Session ";" ;
TDefArea.   TypeDef ::= "area"     UIdent "@" AnyInt ":" UIdent ";" ;

FuncArgBType. FuncArg ::= LIdent ":" BType ;
FuncArgVType. FuncArg ::= LIdent ":" LIdent ;
FuncArgQType. FuncArg ::= QType ;

separator nonempty FuncArg "," ;

ProcArgSess.  ProcArg ::= "^" LIdent ":" Session ;
ProcArgType.  ProcArg ::=     LIdent ":" Type ;
separator ProcArg "," ;

rules  Global  ::= LIdent "=" Expr ";" ;

-- func myFunction(x: a, y: Something, z: Int | z >= 0) -> Int { ... }
-- func myFunction(x: a, y: Something, z: Int | z >= 0) -> w : Int | w <= 0 { ... }
rules  Func    ::= "func" LIdent "(" [FuncArg] ")" "->" Type "{" Expr "}" ;

rules ProcDef ::= "proc" UIdent "(" [ProcArg] ")" "{" Proc "}" ;

rules TopDef ::= TypeDef | Global | Func | ProcDef ;
terminator  TopDef "" ;

rules Prog ::= [TopDef] ;

comment "//" ;

-- Only export nessecary parsers.
entrypoints Prog, TopDef, TypeDef, Type, Session, Expr, Proc, ProcArg ;

