-- Tokens

position token UIdent (upper (letter | digit | '_')*) ;
position token LIdent (lower (letter | digit | '_')*) ;
position token LScopedIdent (lower (letter | digit | '_' | {"::"})*) ;
position token DecInt ('0' | ('~'? ["123456789"] digit*)) ;
position token HexInt ({"0x"} ["0123456789abcdefABCDEF"]+) ;
position token OctInt ({"0o"} ["01234567"]+) ;
position token BinInt ({"0b"} ["01"]+) ;

rules AnyInt ::= DecInt | HexInt | OctInt | BinInt ;

-- liquid types
-- See https://ucsd-progsys.github.io/liquidhaskell-tutorial/02-logic.html
-- and the definition of Expr at
-- https://github.com/ucsd-progsys/liquid-fixpoint/blob/master/src/Language/Fixpoint/Types/Refinements.hs

QPredIff. QPred1 ::= QPred2 "<->" QPred2 ;

QPredImp. QPred2 ::= QPred3 "->" QPred3 ;

QPredOr.  QPred3 ::= QPred4 "||" QPred4 ;

QPredAnd. QPred4 ::= QPred5 "&&" QPred5 ;

QPredNot. QPred5 ::= "!" QPred6 ;

QPredTrue.  QPred6 ::= "true" ;
QPredFalse. QPred6 ::= "false" ;
QPredAtom.  QPred6 ::= QExpr QRel QExpr ;

coercions QPred 6 ;

QRelEq. QRel ::= "==" ;
QRelNe. QRel ::= "!=" ;
QRelGe. QRel ::= ">=" ;
QRelLe. QRel ::= "<=" ;
QRelGt. QRel ::= ">" ;
QRelLt. QRel ::= "<" ;

QExprAdd. QExpr1 ::= QExpr1 "+" QExpr2 ;
QExprSub. QExpr1 ::= QExpr1 "-" QExpr2 ;

QExprMul. QExpr2 ::= AnyInt "*" QExpr3 ;

QExprInt. QExpr3 ::= AnyInt ;
QExprVar. QExpr3 ::= LIdent ;
QExprApp. QExpr3 ::= LIdent "(" [CommaSepQExpr] ")" ;

coercions QExpr 3 ;

rules CommaSepQExpr ::= QExpr ;
separator nonempty CommaSepQExpr "," ;

TBit.       BType ::= "Bits" ;
TBool.      BType ::= "Bool" ;
TInt.       BType ::= "Int"    ;
TUnit.      BType ::= "Void" ;
TBuffer.    BType ::= "Buffer" "(" Type ")" ;

QTypeVar.   QType ::= "{" LIdent ":" UnqualType "|" QPred "}" ;
QTypeNoVar. QType ::= "{"            UnqualType "|" QPred "}" ;

rules CommaSepType ::= Type ;
separator nonempty CommaSepType "," ;

-- Type is split into TypeA and TypeB. TypeB is used in sessions where
-- TypeNamed would introduce a shift/reduce conflict.
TypeNamed.       TypeA ::= UIdent ;
TypeNamedParams. TypeB ::= UIdent "(" [CommaSepType] ")" ;
TypeBase.        TypeB ::= BType ;
TypeVar.         TypeB ::= LIdent ;
TypeTup.         TypeB ::= "(" CommaSepType "," [CommaSepType] ")" ;

rules UnqualType ::= TypeA | TypeB ;
rules Type ::= QType | UnqualType ;

-- Session Types

rules SessChoice ::= LIdent "=>" Session ;
separator nonempty SessChoice "," ;

SessType.  SessOrTy ::= TypeB ;
SessQType. SessOrTy ::= QType ;
SessSess.  SessOrTy ::= Session ;

SessRec.     Session ::= "rec" UIdent "." Session ;

SessGet.     Session ::= "?" "[" SessOrTy "]" Session ;
SessPut.     Session ::= "!" "[" SessOrTy "]" Session ;
SessSel.     Session ::= "+" "[" [SessChoice] "]" ;
SessCho.     Session ::= "&" "[" [SessChoice] "]" ;

SessEnd.     Session ::= ;
SessVar.     Session ::= UIdent ;
SessVarDual. Session ::= "dual" UIdent ;

-- Expressions

rules LetElem ::= LIdent "=" Expr ;
terminator   LetElem ";" ;

rules LetExpr ::= [LetElem] Expr ;

rules CommaSepExpr ::= Expr ;
separator nonempty CommaSepExpr "," ;

----- Begin operators -----

-- Haskell precedence 2
ELogOr.     Expr3 ::= Expr4 "||" Expr3 ;

-- Haskell precedence 3
ELogAnd.    Expr4 ::= Expr5 "&&" Expr4 ;

-- Haskell precedence 4
EEq.        Expr5 ::= Expr6 "==" Expr6 ;
ENotEq.     Expr5 ::= Expr6 "!=" Expr6 ;
EGtEq.      Expr5 ::= Expr6 ">=" Expr6 ;
ELtEq.      Expr5 ::= Expr6 "<=" Expr6 ;
EGt.        Expr5 ::= Expr6 ">"  Expr6 ;
ELt.        Expr5 ::= Expr6 "<"  Expr6 ;
-- elem, notElem

-- Haskell precedence 5
-- cons, append

-- Haskell precedence 6
EPlus.      Expr7 ::= Expr7 "+" Expr8 ;
EMinus.     Expr7 ::= Expr7 "-" Expr8 ;

-- Haskell precedence 7
ETimes.     Expr8 ::= Expr8 "*" Expr9 ;
EDiv.       Expr8 ::= Expr8 "/" Expr9 ;
EMod.       Expr8 ::= Expr8 "%" Expr9 ;
-- rem, quot, div

-- Haskell precedence 8
-- Power operators
EBitCat.    Expr9  ::= Expr10 "#" Expr9 ;

-- Haskell precedence 9

ELogNot.    Expr12 ::= "!" Expr12 ;

----- End operators -----

EIf.           Expr14 ::= "if" Expr "{" LetExpr "}" "else" "{" LetExpr "}" ;

rules MaybeType ::= ":" Type ;
[].    [MaybeType] ::= ;
(:[]). [MaybeType] ::= MaybeType ;

rules LambdaArg ::= LIdent [MaybeType] ;
separator LambdaArg "," ;

EAbs.          Expr14 ::= "\\" "(" [LambdaArg] ")" [MaybeType] "{" LetExpr "}" ;

ETrue.         Expr14 ::= "true" ;
EFalse.        Expr14 ::= "false" ;
EInt.          Expr14 ::= DecInt ;
EUnit.         Expr14 ::= "void" ;
ETup.          Expr14 ::= "(" CommaSepExpr "," [CommaSepExpr] ")" ;
EApp.          Expr14 ::= LIdent       "(" [CommaSepExpr] ")" ;
EAppScoped.    Expr14 ::= LScopedIdent "(" [CommaSepExpr] ")" ;
EVar.          Expr14 ::= LIdent ;

EAnn.          Expr15 ::= Expr14 ":" Type ;
--EAnnQual.      Expr15 ::= Expr14 ":" QTypeVar ;
--EAnnQualNoVar. Expr15 ::= Expr14 ":" QTypeNoVar ;

coercions   Expr 15 ;

-- Process grammar

-- Builtin channels can have "::" in their name
ChanNotScoped. Chan ::= "^" LIdent ;
ChanScoped.    Chan ::= "^" LScopedIdent ;

ProcNew.     Proc1 ::= "new" "(" "^" LIdent "," "^" LIdent ")"
  ":" Session   ";" Proc1 ;

ProcLet.     Proc1 ::= LIdent "="     Expr      ";" Proc1 ;
ProcGetExpr. Proc1 ::= Chan  "->"     LIdent    ";" Proc1 ;
ProcGetChan. Proc1 ::= Chan  "->" "^" LIdent    ";" Proc1 ;
ProcGetIgn.  Proc1 ::= Chan  "->"     "_"       ";" Proc1 ;

ProcPutExpr. Proc1 ::= Chan  "<-"     Expr      ";" Proc1 ;
ProcPutChan. Proc1 ::= Chan  "<-"     Chan      ";" Proc1 ;

ProcSel.     Proc1 ::= Chan "select"  LIdent    ";" Proc1 ;

rules ConcChoice ::= LIdent "=>" Proc ;
separator nonempty ConcChoice "," ;

ProcCho.     Proc1 ::= Chan "case"
  "{"
    [ ConcChoice ]
  "}" ;

RecInitializerExpr. RecInitializer ::=     LIdent "=" Expr ;
RecInitializerChan. RecInitializer ::= "^" LIdent "=" Chan ;
separator nonempty RecInitializer "," ;

ProcRec.   Proc1 ::= "rec" UIdent "(" [RecInitializer] ")"
  "{" Proc "}" ;

ProcParamExpr. ProcParam ::= Expr ;
ProcParamChan. ProcParam ::= Chan ;
separator ProcParam "," ;

ProcNamed. Proc1 ::= UIdent "(" [ProcParam] ")" ;
ProcFwd.   Proc1 ::= Chan "<->" Chan ;
ProcInact. Proc1 ::= ;

rules ParElem ::= Proc1 ;
separator nonempty ParElem "|" ;

ProcPar.  Proc2 ::= "(" ParElem "|" [ParElem] ")" ;

coercions Proc 2 ;

-- Top level grammar

TDefProto.  TypeDef ::= "protocol" UIdent ":" Session ";" ;
-- TDefArea.   TypeDef ::= "area"     UIdent "@" AnyInt ":" UIdent ";" ;

rules FuncArg ::= LIdent ":" Type ;
--FuncArgType.  FuncArg ::= LIdent ":" UnqualType ;
--FuncArgQType. FuncArg ::= LIdent ":" QTypeNoVar ;
separator nonempty FuncArg "," ;

ProcArgSess.  ProcArg ::= "^" LIdent ":" Session ;
ProcArgType.  ProcArg ::=     LIdent ":" Type ;
--ProcArgQType. ProcArg ::=     LIdent ":" QTypeNoVar ;
separator ProcArg "," ;

rules  Global  ::= LIdent "=" Expr ";" ;

-- func myFunction(x: a, y: Something, z: {Int | z >= 0}) -> Int { ... }
-- func myFunction(x: a, y: Something, z: {Int | z >= 0}) -> {w : Int | w <= 0} { ... }
rules  Func    ::= "func" LIdent "(" [FuncArg] ")" ":" Type "{" LetExpr "}" ;
--FuncRetType.  Func    ::= "func" LIdent "(" [FuncArg] ")" "->" Type "{" LetExpr "}" ;
--FuncRetQType. Func    ::= "func" LIdent "(" [FuncArg] ")" "->" QTypeVar "{" LetExpr "}" ;

rules ProcDef ::= "proc" LIdent "(" [ProcArg] ")" "{" Proc "}" ;

rules TopDef ::= TypeDef | Global | Func | ProcDef ;
terminator  TopDef "" ;

rules Prog ::= [TopDef] ;

comment "//" ;

-- Only export necessary parsers.
entrypoints Prog, Func, Expr, Type, ProcDef, Proc, Session ;

