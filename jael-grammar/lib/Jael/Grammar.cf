-- Tokens

position token UIdent (upper (letter | digit | '_')*) ;
position token LIdent (lower (letter | digit | '_')*) ;
--position token LScopedIdent (lower (letter | digit | '_' | {"::"})*) ;
position token DecInt ('0' | ('~'? ["123456789"] digit*)) ;
position token HexInt ({"0x"} ["0123456789abcdefABCDEF"]+) ;
position token OctInt ({"0o"} ["01234567"]+) ;
position token BinInt ({"0b"} ["01"]+) ;

rules AnyInt ::= DecInt | HexInt | OctInt | BinInt ;

-- liquid types
-- See https://ucsd-progsys.github.io/liquidhaskell-tutorial/02-logic.html
-- and the definition of Expr at
-- https://github.com/ucsd-progsys/liquid-fixpoint/blob/master/src/Language/Fixpoint/Types/Refinements.hs

TBit.       BType ::= "Bits" ;
TBool.      BType ::= "Bool" ;
TInt.       BType ::= "Int" ;
TUnit.      BType ::= "Void" ;
TBuffer.    BType ::= "Buffer" "(" Type ")" ;

QTypeUnqual.  QType ::= "{" LIdent ":" UnqualType "|" Expr "}" ;
QTypeNamed.   QType ::= "{" LIdent ":" UIdent     "|" Expr "}" ;

rules CommaSepType ::= TypeNoUIdent ;
separator nonempty CommaSepType "," ;

TypeNamedParams. UnqualType ::= UIdent "(" [CommaSepType] ")" ;
TypeBuiltin.     UnqualType ::= BType ;
TypeVar.         UnqualType ::= LIdent ;
TypeTup.         UnqualType ::= "(" CommaSepType "," [CommaSepType] ")" ;

rules BaseType   ::= QType | UnqualType ;

TypeFun.   TypeNoUIdent ::= LIdent ":" Type "->" Type ;
TypeBase.  TypeNoUIdent ::= BaseType ;

rules Type ::= TypeNoUIdent | UIdent ;

-- Session Types

rules SessChoice ::= LIdent "=>" Session ;
separator nonempty SessChoice "," ;

SessRec.     SessionNoUIdent ::= "rec" UIdent "." Session ;

SessGet.     SessionNoUIdent ::= "?" "[" SessOrTy "]" Session ;
SessPut.     SessionNoUIdent ::= "!" "[" SessOrTy "]" Session ;
SessSel.     SessionNoUIdent ::= "+" "[" [SessChoice] "]" ;
SessCho.     SessionNoUIdent ::= "&" "[" [SessChoice] "]" ;

SessEnd.     SessionNoUIdent ::= ;
SessVarDual. SessionNoUIdent ::= "dual" UIdent ;

rules Session ::= SessionNoUIdent | UIdent ;

SessType.    SessOrTy ::= TypeNoUIdent ;
SessSess.    SessOrTy ::= SessionNoUIdent ;
SessUIdent.  SessOrTy ::= UIdent ;

-- Expressions

rules LetElem ::= LIdent "=" Expr ;
terminator   LetElem ";" ;

rules CommaSepExpr ::= Expr ;
separator nonempty CommaSepExpr "," ;

rules MaybeType ::= ":" Type ;
[].    [MaybeType] ::= ;
(:[]). [MaybeType] ::= MaybeType ;

rules LambdaArg ::= LIdent [MaybeType] ;
separator LambdaArg "," ;

EAbs.          Expr1 ::= "\\" "(" [LambdaArg] ")" [MaybeType] "->"  Expr1 ;

EIf.           Expr2 ::= "if" Expr3 "then" Expr1 "else" Expr1 ;

ELet.          Expr3 ::= "{" [LetElem] Expr "}" ;

----- Begin operators -----

EIff.       Expr4 ::= Expr5 "<->" Expr5 ;
EImp.       Expr5 ::= Expr6 "-->" Expr6 ;

-- Haskell precedence 2
ELogOr.     Expr6 ::= Expr7 "||" Expr6 ;

-- Haskell precedence 3
ELogAnd.    Expr7 ::= Expr8 "&&" Expr7 ;

-- Haskell precedence 4
EEq.        Expr8 ::= Expr9 "==" Expr9 ;
ENotEq.     Expr8 ::= Expr9 "!=" Expr9 ;
EGtEq.      Expr8 ::= Expr9 ">=" Expr9 ;
ELtEq.      Expr8 ::= Expr9 "<=" Expr9 ;
EGt.        Expr8 ::= Expr9 ">"  Expr9 ;
ELt.        Expr8 ::= Expr9 "<"  Expr9 ;
-- elem, notElem

-- Haskell precedence 5
-- cons, append

-- Haskell precedence 6
EPlus.      Expr9 ::= Expr9 "+" Expr10 ;
EMinus.     Expr9 ::= Expr9 "-" Expr10 ;

-- Haskell precedence 7
ETimes.     Expr10 ::= Expr10 "*" Expr11 ;
EDiv.       Expr10 ::= Expr10 "/" Expr11 ;
EMod.       Expr10 ::= Expr10 "%" Expr11 ;
-- rem, quot, div

-- Haskell precedence 8
-- Power operators
EBitCat.    Expr11  ::= Expr12 "#" Expr11 ;

-- Haskell precedence 9

ELogNot.    Expr12 ::= "!" Expr12 ;

----- End operators -----

ETrue.         Expr17 ::= "true" ;
EFalse.        Expr17 ::= "false" ;
EInt.          Expr17 ::= AnyInt ;
EUnit.         Expr17 ::= "void" ;
ETup.          Expr17 ::= "(" CommaSepExpr "," [CommaSepExpr] ")" ;
EApp.          Expr17 ::= LIdent       "(" [CommaSepExpr] ")" ;
--EAppScoped.    Expr17 ::= LScopedIdent "(" [CommaSepExpr] ")" ;
EVar.          Expr17 ::= LIdent ;

EAnn.          Expr18 ::= "(" Expr17 ":" Type ")" ;

coercions   Expr 18 ;

-- Process grammar

rules Chan ::= "^" LIdent ;

-- Builtin channels can have "::" in their name
--ChanNotScoped. Chan ::= "^" LIdent ;
--ChanScoped.    Chan ::= "^" LScopedIdent ;

ProcNew.     Proc1 ::= "new" "(" "^" LIdent "," "^" LIdent ")"
  ":" Session   ";" Proc1 ;

ProcLet.     Proc1 ::= LIdent "="     Expr      ";" Proc1 ;
ProcGetExpr. Proc1 ::= Chan  "->"     LIdent    ";" Proc1 ;
ProcGetChan. Proc1 ::= Chan  "->" "^" LIdent    ";" Proc1 ;
ProcGetIgn.  Proc1 ::= Chan  "->"     "_"       ";" Proc1 ;

ProcPutExpr. Proc1 ::= Chan  "<-"     Expr      ";" Proc1 ;
ProcPutChan. Proc1 ::= Chan  "<-"     Chan      ";" Proc1 ;

ProcSel.     Proc1 ::= Chan "select"  LIdent    ";" Proc1 ;

rules ConcChoice ::= LIdent "=>" Proc ;
separator nonempty ConcChoice "," ;

ProcCho.     Proc1 ::= Chan "case"
  "{"
    [ ConcChoice ]
  "}" ;

RecInitializerExpr. RecInitializer ::=     LIdent "=" Expr ;
RecInitializerChan. RecInitializer ::= "^" LIdent "=" Chan ;
separator nonempty RecInitializer "," ;

ProcRec.   Proc1 ::= "rec" UIdent "(" [RecInitializer] ")"
  "{" Proc "}" ;

ProcParamExpr. ProcParam ::= Expr ;
ProcParamChan. ProcParam ::= Chan ;
separator ProcParam "," ;

ProcNamed. Proc1 ::= UIdent "(" [ProcParam] ")" ;
ProcFwd.   Proc1 ::= Chan "<->" Chan ;
ProcInact. Proc1 ::= ;

rules ParElem ::= Proc1 ;
separator nonempty ParElem "|" ;

ProcPar.  Proc2 ::= "(" ParElem "|" [ParElem] ")" ;

coercions Proc 2 ;

-- Top level grammar

TDefProto.  TypeDef ::= "protocol" UIdent ":" Session ";" ;
-- TDefArea.   TypeDef ::= "area"     UIdent "@" AnyInt ":" UIdent ";" ;

rules FuncArg ::= LIdent ":" Type ;
separator nonempty FuncArg "," ;

ProcArgSess.  ProcArg ::= "^" LIdent ":" Session ;
ProcArgType.  ProcArg ::=     LIdent ":" Type ;
separator ProcArg "," ;

rules  Global  ::= LIdent "=" Expr ";" ;

-- func myFunction(x: a, y: Something, z: {Int | z >= 0}) : Int = { ... }
-- func myFunction(x: a, y: Something, z: {Int | z >= 0}) : {w : Int | w <= 0} = { ... }
rules  Func    ::= "func" LIdent "(" [FuncArg] ")" ":" Type "=" Expr ;

rules ProcDef ::= "proc" LIdent "(" [ProcArg] ")" "{" Proc "}" ;

rules TopDef ::= TypeDef | Global | Func | ProcDef ;
terminator  TopDef "" ;

rules Prog ::= [TopDef] ;

comment "//" ;

-- Only export necessary parsers.
entrypoints Prog, Func, Expr, Type, ProcDef, Proc, Session ;

