-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Jael.Grammar.Par where
import Jael.Grammar.Abs
import Jael.Grammar.Lex
import Jael.Grammar.ErrM

}

%name pLabel Label
%name pAnyInt AnyInt
%name pLSpc1LIdent LSpc1LIdent
%name pLCom1LIdent LCom1LIdent
%name pBaseType0 BaseType0
%name pBaseType1 BaseType1
%name pBaseType2 BaseType2
%name pBaseType10 BaseType10
%name pBaseType11 BaseType11
%name pBaseType BaseType
%name pBaseType99 BaseType99
%name pLCom1RowType LCom1RowType
%name pLCom1RefType LCom1RefType
%name pLCom2RefType LCom2RefType
%name pRefinedType0 RefinedType0
%name pRefinedType1 RefinedType1
%name pRefinedType2 RefinedType2
%name pRefinedType10 RefinedType10
%name pRefinedType11 RefinedType11
%name pRefinedType RefinedType
%name pRefinedType99 RefinedType99
%name pPattern1 Pattern1
%name pPattern2 Pattern2
%name pPattern3 Pattern3
%name pPattern4 Pattern4
%name pPattern Pattern
%name pLCom1Pattern LCom1Pattern
%name pLCom2Pattern LCom2Pattern
%name pLBar2Pattern LBar2Pattern
%name pLCom1RecPat LCom1RecPat
%name pExpr101 Expr101
%name pExpr102 Expr102
%name pExpr1 Expr1
%name pLSemi1Case LSemi1Case
%name pExpr201 Expr201
%name pExpr202 Expr202
%name pExpr2 Expr2
%name pLSemi1Let LSemi1Let
%name pExpr301 Expr301
%name pExpr302 Expr302
%name pExpr3 Expr3
%name pLSemi1Multi LSemi1Multi
%name pExpr4 Expr4
%name pExpr5 Expr5
%name pExpr6 Expr6
%name pExpr7 Expr7
%name pExpr8 Expr8
%name pExpr9 Expr9
%name pExpr10 Expr10
%name pExpr11 Expr11
%name pExpr1201 Expr1201
%name pExpr1202 Expr1202
%name pExpr1203 Expr1203
%name pExpr12 Expr12
%name pLCom1Expr LCom1Expr
%name pLCom2Expr LCom2Expr
%name pLCom1RecExpr LCom1RecExpr
%name pExpr Expr
%name pAnyType AnyType
%name pLCom1AnyType LCom1AnyType
%name pAlias Alias
%name pMaybeLCom1Expr MaybeLCom1Expr
%name pSession0 Session0
%name pSession1 Session1
%name pSession2 Session2
%name pSession12 Session12
%name pSession99 Session99
%name pSession Session
%name pLCom1SChoice LCom1SChoice
%name pChanExp ChanExp
%name pChan Chan
%name pProc1 Proc1
%name pProc2 Proc2
%name pProc Proc
%name pLCom1ChanExp LCom1ChanExp
%name pLCom1PChoice LCom1PChoice
%name pLCom1RecProc LCom1RecProc
%name pLBar2ParProc LBar2ParProc
%name pDataCon DataCon
%name pLBar1DataCon LBar1DataCon
%name pTScheme TScheme
%name pTop Top
%name pLTop LTop
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '!' { PT _ (TS _ 1) }
  '!=' { PT _ (TS _ 2) }
  '$' { PT _ (TS _ 3) }
  '%' { PT _ (TS _ 4) }
  '&' { PT _ (TS _ 5) }
  '&&' { PT _ (TS _ 6) }
  '(' { PT _ (TS _ 7) }
  '(|' { PT _ (TS _ 8) }
  ')' { PT _ (TS _ 9) }
  '*' { PT _ (TS _ 10) }
  '+' { PT _ (TS _ 11) }
  ',' { PT _ (TS _ 12) }
  '-' { PT _ (TS _ 13) }
  '-->' { PT _ (TS _ 14) }
  '->' { PT _ (TS _ 15) }
  '.' { PT _ (TS _ 16) }
  '/' { PT _ (TS _ 17) }
  ':' { PT _ (TS _ 18) }
  ':=' { PT _ (TS _ 19) }
  ';' { PT _ (TS _ 20) }
  '<' { PT _ (TS _ 21) }
  '<-' { PT _ (TS _ 22) }
  '<->' { PT _ (TS _ 23) }
  '<=' { PT _ (TS _ 24) }
  '=' { PT _ (TS _ 25) }
  '==' { PT _ (TS _ 26) }
  '>' { PT _ (TS _ 27) }
  '>=' { PT _ (TS _ 28) }
  '?' { PT _ (TS _ 29) }
  '@' { PT _ (TS _ 30) }
  '[' { PT _ (TS _ 31) }
  '\\' { PT _ (TS _ 32) }
  '\\(' { PT _ (TS _ 33) }
  '\\case' { PT _ (TS _ 34) }
  ']' { PT _ (TS _ 35) }
  '_' { PT _ (TS _ 36) }
  'case' { PT _ (TS _ 37) }
  'cases' { PT _ (TS _ 38) }
  'coind' { PT _ (TS _ 39) }
  'corec' { PT _ (TS _ 40) }
  'data' { PT _ (TS _ 41) }
  'dual' { PT _ (TS _ 42) }
  'else' { PT _ (TS _ 43) }
  'forall' { PT _ (TS _ 44) }
  'if' { PT _ (TS _ 45) }
  'in' { PT _ (TS _ 46) }
  'let' { PT _ (TS _ 47) }
  'new' { PT _ (TS _ 48) }
  'of' { PT _ (TS _ 49) }
  'proc' { PT _ (TS _ 50) }
  'select' { PT _ (TS _ 51) }
  'then' { PT _ (TS _ 52) }
  'type' { PT _ (TS _ 53) }
  '{' { PT _ (TS _ 54) }
  '{}' { PT _ (TS _ 55) }
  '|' { PT _ (TS _ 56) }
  '|)' { PT _ (TS _ 57) }
  '||' { PT _ (TS _ 58) }
  '}' { PT _ (TS _ 59) }
  '~' { PT _ (TS _ 60) }

L_UIdent { PT _ (T_UIdent $$) }
L_LIdent { PT _ (T_LIdent $$) }
L_NegChan { PT _ (T_NegChan $$) }
L_ReftIdent { PT _ (T_ReftIdent $$) }
L_DecInt { PT _ (T_DecInt $$) }
L_HexInt { PT _ (T_HexInt $$) }
L_OctInt { PT _ (T_OctInt $$) }
L_BinInt { PT _ (T_BinInt $$) }


%%

UIdent    :: { UIdent} : L_UIdent { UIdent ($1)}
LIdent    :: { LIdent} : L_LIdent { LIdent ($1)}
NegChan    :: { NegChan} : L_NegChan { NegChan ($1)}
ReftIdent    :: { ReftIdent} : L_ReftIdent { ReftIdent ($1)}
DecInt    :: { DecInt} : L_DecInt { DecInt ($1)}
HexInt    :: { HexInt} : L_HexInt { HexInt ($1)}
OctInt    :: { OctInt} : L_OctInt { OctInt ($1)}
BinInt    :: { BinInt} : L_BinInt { BinInt ($1)}

Label :: { Label }
Label : LIdent { Jael.Grammar.Abs.LabelLIdent $1 }
      | DecInt { Jael.Grammar.Abs.LabelDecInt $1 }
AnyInt :: { AnyInt }
AnyInt : DecInt { Jael.Grammar.Abs.AnyIntDec $1 }
       | HexInt { Jael.Grammar.Abs.AnyIntHex $1 }
       | OctInt { Jael.Grammar.Abs.AnyIntOct $1 }
       | BinInt { Jael.Grammar.Abs.AnyIntBin $1 }
LSpc1LIdent :: { LSpc1LIdent }
LSpc1LIdent : LIdent LSpc1LIdent { Jael.Grammar.Abs.LSpc1LIdentCon $1 $2 }
            | LIdent { Jael.Grammar.Abs.LSpc1LIdentNil $1 }
LCom1LIdent :: { LCom1LIdent }
LCom1LIdent : LIdent ',' LCom1LIdent { Jael.Grammar.Abs.LCom1LIdentCon $1 $3 }
            | LIdent { Jael.Grammar.Abs.LCom1LIdentNil $1 }
BaseType0 :: { BaseType }
BaseType0 : RefinedType11 '->' RefinedType { Jael.Grammar.Abs.BTypeFun $1 $3 }
          | LIdent ':' RefinedType11 '->' RefinedType { Jael.Grammar.Abs.BTypeFunDep $1 $3 $5 }
BaseType1 :: { BaseType }
BaseType1 : LIdent { Jael.Grammar.Abs.BTypeVar $1 }
          | '{}' { Jael.Grammar.Abs.BTypeRecEmp }
          | '{' LIdent '}' { Jael.Grammar.Abs.BTypeRecPoly $2 }
          | '{' LCom1RowType '}' { Jael.Grammar.Abs.BTypeRec $2 }
          | '{' LCom1RowType '|' LIdent '}' { Jael.Grammar.Abs.BTypeRecExt $2 $4 }
          | '(' LCom2RefType ')' { Jael.Grammar.Abs.BTypeTup $2 }
          | '[' RefinedType ';' AnyInt ']' { Jael.Grammar.Abs.BTypeArr $2 $4 }
BaseType2 :: { BaseType }
BaseType2 : Alias { Jael.Grammar.Abs.BTypeAlias $1 }
BaseType10 :: { BaseType }
BaseType10 : BaseType0 { $1 }
BaseType11 :: { BaseType }
BaseType11 : BaseType1 { $1 } | BaseType2 { $1 }
BaseType :: { BaseType }
BaseType : BaseType10 { $1 } | BaseType11 { $1 }
BaseType99 :: { BaseType }
BaseType99 : BaseType0 { $1 } | BaseType1 { $1 }
LCom1RowType :: { LCom1RowType }
LCom1RowType : LIdent ':' RefinedType ',' LCom1RowType { Jael.Grammar.Abs.LCom1RowTypeCon $1 $3 $5 }
             | LIdent ':' RefinedType { Jael.Grammar.Abs.LCom1RowTypeNil $1 $3 }
LCom1RefType :: { LCom1RefType }
LCom1RefType : RefinedType ',' LCom1RefType { Jael.Grammar.Abs.LCom1RefTypeCon $1 $3 }
             | RefinedType { Jael.Grammar.Abs.LCom1RefTypeNil $1 }
LCom2RefType :: { LCom2RefType }
LCom2RefType : RefinedType ',' LCom2RefType { Jael.Grammar.Abs.LCom2RefTypeCon $1 $3 }
             | RefinedType ',' RefinedType { Jael.Grammar.Abs.LCom2RefTypeNil $1 $3 }
RefinedType0 :: { RefinedType }
RefinedType0 : BaseType0 { Jael.Grammar.Abs.RTypeBase0 $1 }
RefinedType1 :: { RefinedType }
RefinedType1 : '(|' LIdent ':' '(' BaseType10 ')' '|' Expr '|)' { Jael.Grammar.Abs.RTypeQualFun $2 $5 $8 }
             | '(|' LIdent ':' BaseType11 '|' Expr '|)' { Jael.Grammar.Abs.RTypeQualBase $2 $4 $6 }
             | BaseType1 { Jael.Grammar.Abs.RTypeBase1 $1 }
RefinedType2 :: { RefinedType }
RefinedType2 : BaseType2 { Jael.Grammar.Abs.RTypeBase2 $1 }
RefinedType10 :: { RefinedType }
RefinedType10 : RefinedType0 { $1 }
RefinedType11 :: { RefinedType }
RefinedType11 : RefinedType1 { $1 }
              | RefinedType2 { $1 }
              | '(' RefinedType0 ')' { $2 }
RefinedType :: { RefinedType }
RefinedType : RefinedType10 { $1 } | RefinedType11 { $1 }
RefinedType99 :: { RefinedType }
RefinedType99 : RefinedType0 { $1 } | RefinedType1 { $1 }
Pattern1 :: { Pattern }
Pattern1 : LBar2Pattern { Jael.Grammar.Abs.PatPar $1 }
         | Pattern2 { $1 }
Pattern2 :: { Pattern }
Pattern2 : '$' LIdent { Jael.Grammar.Abs.PatVar $2 }
         | '$' LIdent '@' Pattern4 { Jael.Grammar.Abs.PatVarAt $2 $4 }
         | Pattern3 { $1 }
Pattern3 :: { Pattern }
Pattern3 : LIdent '(' LCom1Pattern ')' { Jael.Grammar.Abs.PatConArg $1 $3 }
         | LIdent { Jael.Grammar.Abs.PatCon $1 }
         | Pattern4 { $1 }
Pattern4 :: { Pattern }
Pattern4 : '_' { Jael.Grammar.Abs.PatWild }
         | AnyInt { Jael.Grammar.Abs.PatInt $1 }
         | '~' DecInt { Jael.Grammar.Abs.PatNegInt $2 }
         | '{}' { Jael.Grammar.Abs.PatRecEmp }
         | '{' LCom1RecPat '}' { Jael.Grammar.Abs.PatRec $2 }
         | '{' LCom1RecPat '|' '$' LIdent '}' { Jael.Grammar.Abs.PatRecPoly $2 $5 }
         | '{' LCom1RecPat '|' '_' '}' { Jael.Grammar.Abs.PatRecWild $2 }
         | '(' LCom2Pattern ')' { Jael.Grammar.Abs.PatTup $2 }
         | '[' LCom1Pattern ']' { Jael.Grammar.Abs.PatArr $2 }
         | '(' Pattern ')' { $2 }
Pattern :: { Pattern }
Pattern : Pattern1 { $1 }
LCom1Pattern :: { LCom1Pattern }
LCom1Pattern : Pattern ',' LCom1Pattern { Jael.Grammar.Abs.LCom1PatternCon $1 $3 }
             | Pattern { Jael.Grammar.Abs.LCom1PatternNil $1 }
LCom2Pattern :: { LCom2Pattern }
LCom2Pattern : Pattern ',' LCom2Pattern { Jael.Grammar.Abs.LCom2PatternCon $1 $3 }
             | Pattern ',' Pattern { Jael.Grammar.Abs.LCom2PatternNil $1 $3 }
LBar2Pattern :: { LBar2Pattern }
LBar2Pattern : Pattern2 '||' LBar2Pattern { Jael.Grammar.Abs.LBar2PatternCon $1 $3 }
             | Pattern2 '||' Pattern2 { Jael.Grammar.Abs.LBar2PatternNil $1 $3 }
LCom1RecPat :: { LCom1RecPat }
LCom1RecPat : LIdent '=' Pattern ',' LCom1RecPat { Jael.Grammar.Abs.LCom1RecPatCon $1 $3 $5 }
            | LIdent '=' Pattern { Jael.Grammar.Abs.LCom1RecPatNil $1 $3 }
Expr101 :: { Expr }
Expr101 : '\\(' LCom1Pattern ')' '->' Expr { Jael.Grammar.Abs.EAbs $2 $5 }
Expr102 :: { Expr }
Expr102 : '\\case' '{' LSemi1Case '}' { Jael.Grammar.Abs.EAbsCase $3 }
Expr1 :: { Expr }
Expr1 : Expr101 { $1 } | Expr102 { $1 } | Expr2 { $1 }
LSemi1Case :: { LSemi1Case }
LSemi1Case : Pattern '->' Expr ';' LSemi1Case { Jael.Grammar.Abs.LSemi1CaseCon $1 $3 $5 }
           | Pattern '->' Expr { Jael.Grammar.Abs.LSemi1CaseNil $1 $3 }
Expr201 :: { Expr }
Expr201 : 'case' Expr 'of' '{' LSemi1Case '}' { Jael.Grammar.Abs.ECase $2 $5 }
Expr202 :: { Expr }
Expr202 : 'let' '{' LSemi1Let '}' 'in' Expr2 { Jael.Grammar.Abs.ELet $3 $6 }
Expr2 :: { Expr }
Expr2 : Expr201 { $1 } | Expr202 { $1 } | Expr3 { $1 }
LSemi1Let :: { LSemi1Let }
LSemi1Let : Pattern '=' Expr ';' LSemi1Let { Jael.Grammar.Abs.LSemi1LetCon $1 $3 $5 }
          | Pattern '=' Expr { Jael.Grammar.Abs.LSemi1LetNil $1 $3 }
Expr301 :: { Expr }
Expr301 : 'if' Expr 'then' Expr3 'else' Expr3 { Jael.Grammar.Abs.EIf $2 $4 $6 }
Expr302 :: { Expr }
Expr302 : 'if' '{' LSemi1Multi '}' { Jael.Grammar.Abs.EMultiIf $3 }
Expr3 :: { Expr }
Expr3 : Expr301 { $1 } | Expr302 { $1 } | Expr4 { $1 }
LSemi1Multi :: { LSemi1Multi }
LSemi1Multi : Expr2 '->' Expr ';' LSemi1Multi { Jael.Grammar.Abs.LSemi1MultiCon $1 $3 $5 }
            | Expr2 '->' Expr { Jael.Grammar.Abs.LSemi1MultiNil $1 $3 }
Expr4 :: { Expr }
Expr4 : Expr5 '<->' Expr4 { Jael.Grammar.Abs.EIff $1 $3 }
      | Expr5 { $1 }
Expr5 :: { Expr }
Expr5 : Expr6 '-->' Expr6 { Jael.Grammar.Abs.EImp $1 $3 }
      | Expr6 { $1 }
Expr6 :: { Expr }
Expr6 : Expr7 '||' Expr6 { Jael.Grammar.Abs.ELogOr $1 $3 }
      | Expr7 { $1 }
Expr7 :: { Expr }
Expr7 : Expr8 '&&' Expr7 { Jael.Grammar.Abs.ELogAnd $1 $3 }
      | Expr8 { $1 }
Expr8 :: { Expr }
Expr8 : Expr9 '==' Expr9 { Jael.Grammar.Abs.EEq $1 $3 }
      | Expr9 '!=' Expr9 { Jael.Grammar.Abs.ENotEq $1 $3 }
      | Expr9 '>=' Expr9 { Jael.Grammar.Abs.EGtEq $1 $3 }
      | Expr9 '<=' Expr9 { Jael.Grammar.Abs.ELtEq $1 $3 }
      | Expr9 '>' Expr9 { Jael.Grammar.Abs.EGt $1 $3 }
      | Expr9 '<' Expr9 { Jael.Grammar.Abs.ELt $1 $3 }
      | Expr9 { $1 }
Expr9 :: { Expr }
Expr9 : Expr10 '+' Expr9 { Jael.Grammar.Abs.EPlus $1 $3 }
      | Expr10 '-' Expr9 { Jael.Grammar.Abs.EMinus $1 $3 }
      | Expr10 { $1 }
Expr10 :: { Expr }
Expr10 : Expr11 '*' Expr10 { Jael.Grammar.Abs.ETimes $1 $3 }
       | Expr11 '/' Expr10 { Jael.Grammar.Abs.EDiv $1 $3 }
       | Expr11 '%' Expr10 { Jael.Grammar.Abs.EMod $1 $3 }
       | Expr11 { $1 }
Expr11 :: { Expr }
Expr11 : '!' Expr11 { Jael.Grammar.Abs.ELogNot $2 }
       | '~' Expr11 { Jael.Grammar.Abs.ENegate $2 }
       | Expr12 { $1 }
Expr1201 :: { Expr }
Expr1201 : Expr12 '.' Label { Jael.Grammar.Abs.ERecSel $1 $3 }
         | Expr12 '\\' Label { Jael.Grammar.Abs.ERecRem $1 $3 }
Expr1202 :: { Expr }
Expr1202 : AnyInt { Jael.Grammar.Abs.EInt $1 }
         | LIdent { Jael.Grammar.Abs.EVar $1 }
         | ReftIdent { Jael.Grammar.Abs.EReftVar $1 }
         | Expr12 '(' LCom1Expr ')' { Jael.Grammar.Abs.EApp $1 $3 }
         | '(' LCom2Expr ')' { Jael.Grammar.Abs.ETup $2 }
         | '[' LCom1Expr ']' { Jael.Grammar.Abs.EArr $2 }
Expr1203 :: { Expr }
Expr1203 : '{}' { Jael.Grammar.Abs.ERecEmpt }
         | '{' LCom1RecExpr '}' { Jael.Grammar.Abs.ERec $2 }
         | '{' LCom1RecExpr '|' Expr '}' { Jael.Grammar.Abs.ERecPoly $2 $4 }
Expr12 :: { Expr }
Expr12 : Expr1201 { $1 }
       | Expr1202 { $1 }
       | Expr1203 { $1 }
       | '(' Expr ')' { $2 }
LCom1Expr :: { LCom1Expr }
LCom1Expr : Expr ',' LCom1Expr { Jael.Grammar.Abs.LCom1ExprCon $1 $3 }
          | Expr { Jael.Grammar.Abs.LCom1ExprNil $1 }
LCom2Expr :: { LCom2Expr }
LCom2Expr : Expr ',' LCom2Expr { Jael.Grammar.Abs.LCom2ExprCon $1 $3 }
          | Expr ',' Expr { Jael.Grammar.Abs.LCom2ExprNil $1 $3 }
LCom1RecExpr :: { LCom1RecExpr }
LCom1RecExpr : LIdent '=' Expr ',' LCom1RecExpr { Jael.Grammar.Abs.LCom1RecExtendCon $1 $3 $5 }
             | LIdent '<-' LIdent ',' LCom1RecExpr { Jael.Grammar.Abs.LCom1RecRenameCon $1 $3 $5 }
             | LIdent ':=' Expr ',' LCom1RecExpr { Jael.Grammar.Abs.LCom1RecUpdateCon $1 $3 $5 }
             | LIdent '=' Expr { Jael.Grammar.Abs.LCom1RecExtendNil $1 $3 }
             | LIdent '<-' LIdent { Jael.Grammar.Abs.LCom1RecRenameNil $1 $3 }
             | LIdent ':=' Expr { Jael.Grammar.Abs.LCom1RecUpdateNil $1 $3 }
Expr :: { Expr }
Expr : Expr1 { $1 }
AnyType :: { AnyType }
AnyType : RefinedType99 { Jael.Grammar.Abs.AnyTypeRType $1 }
        | Session99 { Jael.Grammar.Abs.AnyTypeSess $1 }
        | Alias { Jael.Grammar.Abs.AnyTypeAlias $1 }
LCom1AnyType :: { LCom1AnyType }
LCom1AnyType : AnyType ',' LCom1AnyType { Jael.Grammar.Abs.LCom1AnyTypeCon $1 $3 }
             | AnyType { Jael.Grammar.Abs.LCom1AnyTypeNil $1 }
Alias :: { Alias }
Alias : UIdent { Jael.Grammar.Abs.AliasNoParam $1 }
      | UIdent '(' LCom1AnyType MaybeLCom1Expr ')' { Jael.Grammar.Abs.AliasParam $1 $3 $4 }
MaybeLCom1Expr :: { MaybeLCom1Expr }
MaybeLCom1Expr : ';' LCom1Expr { Jael.Grammar.Abs.MaybeLCom1ExprJust $2 }
               | {- empty -} { Jael.Grammar.Abs.MaybeLCom1ExprNothing }
Session0 :: { Session }
Session0 : 'coind' UIdent '.' Session12 { Jael.Grammar.Abs.SessRec $2 $4 }
Session1 :: { Session }
Session1 : '?' '[' AnyType ']' Session { Jael.Grammar.Abs.SessGet $3 $5 }
         | '!' '[' AnyType ']' Session { Jael.Grammar.Abs.SessPut $3 $5 }
         | '+' '[' LCom1SChoice ']' { Jael.Grammar.Abs.SessSel $3 }
         | '&' '[' LCom1SChoice ']' { Jael.Grammar.Abs.SessCho $3 }
         | 'dual' Session2 { Jael.Grammar.Abs.SessDual $2 }
         | {- empty -} { Jael.Grammar.Abs.SessEnd }
Session2 :: { Session }
Session2 : Alias { Jael.Grammar.Abs.SessAlias $1 }
Session12 :: { Session }
Session12 : Session1 { $1 } | Session2 { $1 }
Session99 :: { Session }
Session99 : Session0 { $1 } | Session1 { $1 }
Session :: { Session }
Session : Session0 { $1 } | Session1 { $1 } | Session2 { $1 }
LCom1SChoice :: { LCom1SChoice }
LCom1SChoice : LIdent '->' Session ',' LCom1SChoice { Jael.Grammar.Abs.LCom1SChoiceCon $1 $3 $5 }
             | LIdent '->' Session { Jael.Grammar.Abs.LCom1SChoiceNil $1 $3 }
ChanExp :: { ChanExp }
ChanExp : NegChan { Jael.Grammar.Abs.ChanExprNeg $1 }
        | Expr { Jael.Grammar.Abs.ChanExprExp $1 }
Chan :: { Chan }
Chan : LIdent { Jael.Grammar.Abs.ChanPos $1 }
     | NegChan { Jael.Grammar.Abs.ChanNeg $1 }
Proc1 :: { Proc }
Proc1 : '{' LBar2ParProc '}' { Jael.Grammar.Abs.ProcPar $2 }
Proc2 :: { Proc }
Proc2 : 'let' Pattern '=' Expr Proc { Jael.Grammar.Abs.ProcLet $2 $4 $5 }
      | 'new' LIdent ':' Session Proc { Jael.Grammar.Abs.ProcNew $2 $4 $5 }
      | Chan '->' Pattern Proc { Jael.Grammar.Abs.ProcGet $1 $3 $4 }
      | Chan '<-' ChanExp Proc { Jael.Grammar.Abs.ProcPut $1 $3 $4 }
      | Chan 'select' LIdent Proc { Jael.Grammar.Abs.ProcSel $1 $3 $4 }
      | Chan 'cases' '{' LCom1PChoice '}' { Jael.Grammar.Abs.ProcChoice $1 $4 }
      | 'corec' LIdent '(' LCom1RecProc ')' Proc { Jael.Grammar.Abs.ProcRec $2 $4 $6 }
      | LIdent '(' LCom1ChanExp ')' { Jael.Grammar.Abs.ProcNamed $1 $3 }
      | Chan '<->' Chan { Jael.Grammar.Abs.ProcFwd $1 $3 }
      | {- empty -} { Jael.Grammar.Abs.ProcEnd }
Proc :: { Proc }
Proc : Proc1 { $1 } | Proc2 { $1 }
LCom1ChanExp :: { LCom1ChanExp }
LCom1ChanExp : ChanExp ',' LCom1ChanExp { Jael.Grammar.Abs.LCom1ChanExpCon $1 $3 }
             | ChanExp { Jael.Grammar.Abs.LCom1ChanExpNil $1 }
LCom1PChoice :: { LCom1PChoice }
LCom1PChoice : LIdent '->' Proc ',' LCom1PChoice { Jael.Grammar.Abs.LCom1PChoiceCon $1 $3 $5 }
             | LIdent '->' Proc { Jael.Grammar.Abs.LCom1PChoiceNil $1 $3 }
LCom1RecProc :: { LCom1RecProc }
LCom1RecProc : Pattern '=' ChanExp ',' LCom1RecProc { Jael.Grammar.Abs.LCom1RecProcCon $1 $3 $5 }
             | Pattern '=' ChanExp { Jael.Grammar.Abs.LCom1RecProcNil $1 $3 }
LBar2ParProc :: { LBar2ParProc }
LBar2ParProc : Proc2 '|' LBar2ParProc { Jael.Grammar.Abs.LBar2ParProcCon $1 $3 }
             | Proc2 '|' Proc2 { Jael.Grammar.Abs.LBar2ParProcNil $1 $3 }
DataCon :: { DataCon }
DataCon : LIdent { Jael.Grammar.Abs.DataConEmpt $1 }
        | LIdent '(' LCom1RefType ')' { Jael.Grammar.Abs.DataConArgs $1 $3 }
LBar1DataCon :: { LBar1DataCon }
LBar1DataCon : DataCon '|' LBar1DataCon { Jael.Grammar.Abs.LBar1DataConCon $1 $3 }
             | DataCon { Jael.Grammar.Abs.LBar1DataConNil $1 }
TScheme :: { TScheme }
TScheme : 'forall' LSpc1LIdent '.' RefinedType { Jael.Grammar.Abs.TPoly $2 $4 }
        | RefinedType { Jael.Grammar.Abs.TMono $1 }
Top :: { Top }
Top : LIdent ':' TScheme { Jael.Grammar.Abs.TopTypeDef $1 $3 }
    | 'type' UIdent '=' AnyType { Jael.Grammar.Abs.TopType $2 $4 }
    | 'type' UIdent '(' LCom1LIdent ')' '=' AnyType { Jael.Grammar.Abs.TopTypeParam $2 $4 $7 }
    | 'data' UIdent '=' LBar1DataCon { Jael.Grammar.Abs.TopData $2 $4 }
    | 'data' UIdent '(' LCom1LIdent ')' '=' LBar1DataCon { Jael.Grammar.Abs.TopDataParam $2 $4 $7 }
    | LIdent '=' Expr { Jael.Grammar.Abs.TopExpr $1 $3 }
    | LIdent '(' LCom1Pattern ')' '=' Expr { Jael.Grammar.Abs.TopFunc $1 $3 $6 }
    | 'let' Pattern '=' Expr { Jael.Grammar.Abs.TopPat $2 $4 }
    | 'proc' LIdent '(' LCom1Pattern ')' '=' Proc { Jael.Grammar.Abs.TopProc $2 $4 $7 }
LTop :: { LTop }
LTop : Top ';' LTop { Jael.Grammar.Abs.LTopCon $1 $3 }
     | Top ';' { Jael.Grammar.Abs.LTopNil $1 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

